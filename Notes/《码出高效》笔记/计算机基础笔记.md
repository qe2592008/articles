# 计算机基础
## 二进制的世界
二进制就是设定基数为2，进位规则为“逢二进一”，借位规则为“借一当二”。
### 转换
二进制与十进制之间的转换方式：
```text
1=1         2<sup>0</sup>=1
10=2        2<sup>1</sup>=2
100=4       2<sup>2</sup>=4
1000=8      2<sup>3</sup>=8
11000=24    2<sup>4</sup>+2<sup>3</sup>=24  
```
8位的二进制可以表示的最大值为：11111111，转换为十进制为255。那么就是说，8位二进制可以表示0-255之间的所有数值，总共256个数。

平时所说的32位机器，指的就是能够同时处理字长为32位的电路信号。
### 负数
如上节所说，8位的二进制数，如果将第一位二进制数视为符号位，0表示正数，1表示负数，那么这个区间可以表示的范围就变成：-128到127。

负数的二进制表示法为：补码形式，即其绝对值的二进制的反码+1的结果。

其实正数的二进制表示也是补码形式，只不过其补码与原码、反码一致。

为什么采用补码形式呢，主要就是为了将减法运算转换为加法运算，都使用加法器来实现计算。
### 运算
#### 加减运算

#### 位移运算
- 左移（<<）
整体左移，低位补0，那么最左边的符号位就被移掉了，最后的结果是不确定的，可能是正数，也可能是负数。
- 右移（>>）
整体右移，高位补0或1，正数高位补0，负数补1。

右移一位可视为除以2，奇数的二进制值末尾为1，右移一位就会将这个1去掉，直接抹除数据表明这种方式计算出的除法结果是不准确的，近似的。
- 无符号右移（>>>）
无符号右移是整体右移，高位补0。这时不考虑原数的正负。

这一般适用于进行高低位截取的，无关正负的影响。这与前面的左右移不同，上面的是进行数值计算，关乎正负。

为何负数不断地无符号向右移动的最小值是1呢？在实际编程中，位移运算仅作用于整型（32位）和长整型（64位）数上，假如在整型数上移动位数是32位，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个mod 32的结果，即35>>1与35>>33是一样的结果。如果是长整型，mod64，即35<<1与35<<65的结果是一样的。负数在无符号往右移动63位时，除最右边为1外，左边均为0，达到最小值1，如果>>>64，则为其原数值本身。
## 浮点数
浮点数采用科学计数法表示，由符号位、有效数字、指数位三部分组成。
### 单精度浮点数
- 符号位：首位，1-负数，0-正数
- 阶码位：第二位-第九位（共8位），
### 双精度浮点数

##

##

##

##

##

