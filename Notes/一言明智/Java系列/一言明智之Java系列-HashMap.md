HashMap1.7和1.8版本实现方式大不相同
    
    1.7版：采用头插法的链表来处理hash冲突的元素，采用头插法在进行扩容的时候，极易形成互相引用的环形链表，造成内存100%。
    1.8版：采用尾插法的链表和红黑树来处理hash冲突的元素，尾插法彻底解决了扩容形成循环链表的问题，同时使用红黑树来优化冲突元素较多的节点的查询操作。
    
无论是老版还是新版，HashMap都是一个非线程安全的集合，多线程环境推荐使用ConcurrentHashMap。

添加元素：

    先计算key的hash值（新旧版hash算法不同），与数组容量-1进行与操作定位元素的桶位。没有元素直接存储，有元素就需要进行冲突解决，优先使用链表，1.7采用头插法，插入之前要检查是否有同key元素，若有直接替换value即可。1.8版采用尾插法，从头遍历到尾，没有同key元素，直接放到链表尾部。
    添加元素时必然需要校验是否需要扩容，1.7版在元素添加之前进行校验并扩容，1.8版本在添加元素之后校验并扩容，扩容条件基本相同，前者的条件是元素总量达到阈值且当前数组位有元素，后者则是仅判断是否达到阈值。
    
查询元素
    
    先计算key的hash值，再定位桶位，遍历链表获取元素，1.8多了红黑树的遍历。
    
遍历元素
    
    
    
扩容：
由于新旧版结构发生了一点变化，这变化主要就体现在了扩容上了。
    
    1.7版扩容：扩容为2倍旧容量，所有元素重新hash,定位新桶位，将元素迁移到新的数组。如果存在hash冲突，还是链表解决，可见元素被全部打乱重新安置。
    1.8版扩容：扩容为2倍旧容量，元素链表或者红黑树被拆分成为两个小链表或小树（树太小，元素低于6个，退化为链表）安置于新数组的原位与原位+旧数组容量位。分拆规则是将元素key的hash值与旧数组容量相与，结果要不全为0，要不有一位为1，其余为0，分成两种情况，根据这个结果来分拆链表和树，为0的位于原位（低位），为1的位于高位。
    
