## 1. 概述
- 分布式
- 吞吐量高
- 内置分区
- 复制
- 容错
- 处理速度快，执行2百万写/秒，保证0停机与0数据丢失
- 数据存储到磁盘，并分布式复制保存，保证0丢失
- 底层消息以文件存储，以偏移量来标识
- 即使消息被消费，kafka 也不会立即删除该消息，可以通过配置使得过一段时间后自动删除以释放磁盘空间
## 2. 术语
- producer  生产者-消息的发送者
- consumer  消费者-消息的接收者
- broker    每台实际的Kafka服务器实例
- topic     主题-消息的种类，分类
- partition 分区-一个主题可以分成多个分区，每个分区对应一个文件，分区的目的是为了避免单个文件太大，超出存储上限，分区后可以将数据分别存储到不同的server中去，还可以负载均衡（文件可以在集群内复制备份以防丢失）
- offset    偏移量-表示消息在分区文件中存储的偏移量，是一个long型数字，可以唯一标记一条消息
- replicated   副本-kafka 还可以配置 partitions 需要备份的个数(replicas),每个 partition 将会被备份到多台机器上,以提高可用性，备份的数量可以通过配置文件指定。

总结：一个 topic 对应的多个 partition 分散存储到集群中的多个 broker 上，存储方式是一个 partition 对应一个文件，每个 broker 负责存储在自己机器上的 partition 中的消息读写。

当一个分区备份到多个机器上后，需要选举一个leader作为主机来处理该分区消息的处理，其余机器负责同步分区内容。
由于分区有很多，每个分区必然都存在一个leader机器，kafka 会将 leader 分散到不同的 broker 上，确保整体的负载均衡。
## 3. 结构
一个主题分为3个分区，每个分区会有自己备份机器与主机，其中主机负责该分区消息的接收与消费，每个分配到该分区的消息都是增量式写入分区文件，然后同步到备份机器。
消费方面存在消费者组，组直接与主题关联，即组订阅主题，然后该主题的每个分区会与该组中的一个消费者关联，如果消费者组中有多于3个消费者，那么必然超出的消费者将空闲

流处理：kafka支持流处理：使用producer和consumer API作为输入，利用Kafka做状态存储，使用相同的组机制在stream处理器实例之间进行容错保障。